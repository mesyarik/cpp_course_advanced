
# § 2.1. Pointers (указатели)

Одной из фундаментальных концепций языка Си и языков, произошедших от него (в том числе С++), являются указатели (pointers).

Ни для кого не будет откровением, что во время работы программы компьютер хранит информацию о ее текущем состоянии в своей оперативной памяти. Давайте представим, что речь идет о программе, написанной нами на языке С++. Что входит в понятие “текущее состояние программы”? Вообще говоря, много чего, но как минимум – текущие значения переменных. То есть во время работы программы каждая переменная в течение своего времени жизни должна храниться где-то в оперативной памяти. А значит, у каждой переменной в течение ее жизни должен быть адрес в оперативной памяти. Адрес – это просто номер того байта памяти, начиная с которого в ней записана данная переменная.

Язык Си (как и С++, унаследовавший все это от него) позволяет для данной переменной узнать ее текущий адрес в памяти. Для этого существует унарный оператор \&. Например:

  
```cpp
#include <iostream>
int main() {
	int x = 0;
	std::cout << &x;
}
```
  

Выведется некоторое 16-ричное число, начинающееся с 0x. Это число – номер байта памяти, начиная с которого в ней хранится переменная x во время выполнения программы.

  

На самом деле было бы ошибкой утверждать, что это прямо-таки физический номер байта на планке оперативной памяти. Дело в том, что программа взаимодействует с памятью посредством операционной системы, а та выдает программам так называемую виртуальную память вместо реальной. То есть ОС по некоторому правилу преобразует реальные физические адреса в видимые программе виртуальные адреса, создавая у программы иллюзию, что доступная нам оперативная память – это один большой непрерывный кусок. Но мы не будем сейчас вникать в эти низкоуровневые детали. Для наших целей можно считать, что оперативная память действительно непрерывна, а мы имеем дело с реальными адресами в ней. (Законы Ньютона тоже не всегда выполняются, но при первом знакомстве с механикой можно считать их истинными, игнорируя теорию относительности и квантовые эффекты.)

Естественный вопрос: какой тип имеет выражение ``` &x ```?

Ответ: его тип называется “указатель на инт”, а обозначается ``` int* ``` (звездочка – часть типа). Если бы изначальная переменная была типа double, то типом ее адреса был бы double*, если бы char – то char*, и вообще, оператор \& по любой переменной произвольного типа T позволяет получить некоторое выражение типа T*. Можно завести и переменную для хранения указателя:

```cpp
#include <iostream>
int main() {
 int x = 0;
 int* p = &x;
 std::cout << p;
}
```
  
Оператор взятия адреса \&, как и оператор присваивания и инкремент, требует, чтобы его аргумент был lvalue. Это логично: можно узнавать адрес только у реально существующей в памяти переменной, а не у вычисленного на ходу выражения. Например, выражение \&(x+5) приведет к CE. В свою очередь, оператор \& возвращает rvalue, то есть выражение \&(\&x) тоже приведет к CE (напомню, что выражение \&\&x без скобок вообще будет синтаксической ошибкой, поскольку \&\& распарсится как логическое И).

  

Но если мы завели переменную типа int*, то у нее можно снова взять адрес, и получится выражение типа int**. Таким образом, можно создавать указатели на указатели, указатели на указатели на указатели и т. д.

  

Если существуют переменные типа указателей, то вопрос: сколько места в памяти занимают сами эти переменные? То есть чему равно sizeof(int*)? Как и в случае с размером int, ответ зависит от версии ОС, установленного железа и т.д.. Но скорее всего, на вашем компьютере это будет 8 байт. Дело в том, что 4-байтные указатели позволяли бы индексировать лишь $2^{32}$ байт памяти, то есть около 4 Гб, тогда как современные компьютеры обычно имеют больший запас памяти. Поскольку не принято делать размеры переменных не кратными степеням двойки (например, 6 байт), указатели на современных машинах обычно весят по 8 байт.

  

Операция, обратная к взятию адреса, называется разыменованием указателя (dereference). Эта операция осуществляется с помощью оператора “унарная звездочка”. Тут у многих новичков возникает путаница: звездочка может быть как частью типа, так и оператором (причем если это бинарный оператор, то она обозначает умножение, а если унарный – то разыменование). Может потребоваться некоторое время, чтобы привыкнуть к синтаксису.

  

Оператор разыменования для любого типа T по выражению типа T* возвращает значение типа T, лежащее под данным указателем. Тип T сам может быть указателем, например, разыменование int** даст int*.

  

Пример:

```cpp
#include <iostream>
int main() {
 int a = 0;
 int* p = &a;
 std::cout << p << '\n'; // некоторое 16-ричное число
 int** pp = &p;
 std::cout << pp << '\n'; // другое 16-ричное число
 std::cout << *pp << '\n'; // то же самое, что и std::cout << p
 std::cout << *p << ' ' << **pp << '\n'; // то же самое, что и std::cout << a << ' ' << a
}
```

Почему указатели выводятся на экран именно как 16-ричные числа? Это особенность работы оператора вывода. Несмотря на то, что указатели -- это по сути целые числа, при выводе на экран они печатаются в 16-ричном формате. Это работает точно по такому же принципу, как и вывод значений char на экран (хоть они тоже числа, но выводятся как буквы).  

Разыменование не требует от своего операнда быть каким-либо видом value, а результат разыменования -- это lvalue. Если мы присваиваем новое значение выражению *p, где p -- это указатель, то таким образом мы можем поменять то, что лежит в памяти по данному адресу.

Разумеется, самим указателям тоже можно присваивать новые значения. От такого присваивания не поменяется то, что лежит под указателем, а просто сам указатель начнет указывать на другую ячейку памяти.

Пример:

```cpp
#include <iostream>

int main() {
 int x = 0;
 int* p = &x;
 std::cout << *p; // выведется 0
 *p = 1; // поменялось то, что лежит под указателем p, то есть значение x
 std::cout << x; // выведется 1
 int y = 2;
 p = &y; // p теперь указывает на y, а не на x
 *p = 3; // теперь y равен 3
 std::cout << x << y; // выведется 13 
}
```

TODO: присваивание указателям целых чисел и наоборот

Зачем нужны указатели? Как уже было сказано, указатели существовали еще в языке Си, предшественнике C++. Необходимость введения указателей там иллюстрируется вот какой проблемой. Представим, что мы хотим написать функцию, меняющую значения переданных в нее аргументов. Простейший пример -- мы хотим иметь функцию swap, которая меняет местами значения двух переданных в нее переменных.

```cpp
int main() {
 int x = 0;
 int y = 1;
 std::cout << x << y; // выведется 01
 swap(x, y); // хотим, чтобы от этого x, y обменялись значениями
 std::cout << x << y; // хотим, чтобы теперь вывелось 10
}
```  

Как реализовать функцию swap? Если мы реализуем ее, просто передав туда две переменных типа int, то это не поможет нам достичь цели:

```cpp
void swap(int x, int y) {
 int t = x;
 x = y;
 y = t;
}
```
  
Дело в том, что локальные переменные x, y, с которыми имеет дело функция -- это лишь копии исходных x, y, пусть даже у них совпадают имена. Изменение локальных переменных в функции никак не влияет на исходные переменные, которые были переданы в эту функцию. Так что такая функция бесполезна, она не производит никакого эффекта.

Однако мы можем исправить положение с использованием указателей (поймите, почему звездочки расставлены именно так):

```cpp
void swap(int* x, int* y) {
 int t = *x;
 *x = *y;
 *y = t;
}
```

Теперь, если эту функцию вызвать так: swap(\&x,  \&y) -- значения переменных x, y действительно поменяются местами. В языке Си это был единственный способ создавать функции, которые могут менять значения передаваемых переменных: для этого надо было передавать и принимать не сами переменные, а указатели на них.

Перечислим другие операции, которые можно производить над указателями.

К указателям можно добавлять целые числа, а можно вычитать целые числа из них. То есть к указателям применимы операторы += и -= с правым аргументом int. Также определены бинарные операторы + и -, у которых один из аргументов int, а другой аргумент -- указатель (эти операторы не меняют свои аргументы, разумеется). Это работает по следующему правилу: если мы добавляем к указателю типа T* целое число n, то численное значение указателя увеличивается на n*sizeof(T). Интуитивный смысл у этого такой: представим, что много значений типа T лежат в памяти подряд, и наш указатель указывает на одно из них. Тогда прибавление к указателю целого числа n по смыслу означает “сдвинь указатель, чтобы он указывал на то из значений T, которое лежит на n шагов правее текущего”. При этом один “шаг” имеет размер sizeof(T) байт.

Указатели можно инкрементировать и декрементировать, используя как префиксный, так и постфиксный инкремент/декремент. При этом все особенности работы этих операторов, которые мы упоминали для целых чисел, остаются верными и для указателей. Инкрементирование и декрементирование указателя соответственно работают как прибавление к нему и отнятие от него единицы, то есть численное значение указателя меняется на sizeof(T), если указатель был типа T*.

Добавление чисел к указателям в совокупности с операцией разыменования буквально позволяет нам посмотреть, что лежит в памяти рядом с нашей переменной. Это еще одна особенность языков Си и C++, отличающая их от более “высокоуровневых” языков вроде Java или Python: последние такого сделать не позволяют. Однако следует сразу предупредить, что формально разыменование указателя, который получен не как результат взятия адреса некоторой переменной, а путем арифметических манипуляций, -- это почти всегда UB (кроме случаев, которые мы будем обсуждать позже).  

Пример:

```cpp
#include <iostream>

int main() {
 12345;
 int b = 67890;
 std::cout << &a << ' ' << &b << '\n'; // вероятно, первый адрес будет на 4 меньше второго
 int* p = &b;
 --p; // вероятно, p теперь указывает на a, потому что a и b лежали рядом, но это неточно
 std::cout << *p; // формально UB, но в реальности, вероятно, мы увидим значение a
 ++*p; // все еще UB, но в реальности, вероятно, a увеличится на 1
 std::cout << a; // вероятно, мы увидим 12346
 ++*(p + 1); // а вот теперь b увеличится на 1
 std::cout << b; // должно получиться 67891
}
```
 
Также к UB приводит разыменование указателя, который указывает на переменную, чья область видимости уже закончилась. При этом в реальности, скорее всего, под этим указателем еще какое-то время после окончания жизни переменной будет лежать ее старое значение. Дело в том, что при окончании жизни переменной никакой “очистки” памяти от ее старого значения не происходит: это было бы лишнее действие, лишь замедляющее время работы программы и не приносящее никакой пользы. Но более интересно то, что впоследствии память из-под этой переменной может быть переиспользована под новые переменные. И если мы будем до этих пор хранить указатель на отжившую переменную, изменение памяти под этим указателем может внезапно поменять значения каких-то новых переменных, созданных уже после того, как та старая переменная отжила свое.

Пример:
```cpp
#include <iostream>

int main() {
  int a = 1;
  int* p = &a;
  {
    int b = 2;
    p = &b;
  }
  std::cout << p << '\n';
  std::cout << *p << '\n'; // UB, но в реальности, скорее всего, выведется 2
  int c = 3, d = 4, e = 5, f = 6;
  std::cout << &c << ' ' << &d << ' ' << &e << ' ' << &f << '\n';
  ++*p; // все еще UB, и есть шанс, что поменяется какая-то из переменных c, d, e, f
  std::cout << c << d << e << f; // вероятно, будет что-то отличное от 3456
  std::cout << *p; // вероятно, будет уже не 2
}
```
  
Что, если мы прибавим к указателю настолько большое число, что получившийся указатель выйдет за рамки памяти, доступной нашей программе? Если мы после этого попытаемся подменить значение под этим указателем, не сможем ли мы таким образом изменить какую-то переменную из другой программы? К счастью, не сможем. Как только мы попытаемся это сделать, наша программа будет убита операционной системой и мы получим RE, и это как раз и называется Segmentation fault. На самом деле именно это происходило, когда мы пытались присвоить какое-то значение 10000000-му элементу вектора, когда в векторе было всего 10 элементов.

  

TODO: разность указателей, попытка взять разность указателей разных типов

  

TODO: void* и его особенности

  

TODO: nullptr


