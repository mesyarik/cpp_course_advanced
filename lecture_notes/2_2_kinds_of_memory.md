## § 2.2. Kinds of memory (виды памяти)

Прежде чем двигаться дальше, нам надо обсудить подробнее, из каких частей состоит память работающей программы и что в них хранится.

Когда мы запускаем скомпилированную программу, ОС при запуске выделяет ей во владение какое-то количество оперативной памяти. В реальности эта память может быть выделена не одним цельным куском, а несколькими отдельными, однако ОС создает у программы иллюзию, что доступная ей память образует непрерывный цельный кусок. В первом приближении можно сказать, что выделяемая программе память состоит из трех секций: text, data и stack. Сейчас мы обсудим подробнее каждую из этих секций.

Секция text -- это та часть оперативной памяти, где лежит исполняемый код программы во время ее выполнения.  

Как мы знаем, скомпилированная программа состоит из инструкций в двоичном коде, которые последовательно исполняет процессор. Когда программа не запущена, она хранится в виде двоичного файла на жестком диске. Когда же программа работает, процессор должен откуда-то брать следующие инструкции для исполнения по мере того, как выполняет предыдущие. Загружать инструкции в процессор напрямую из файла было бы крайне непродуктивно. Поэтому при запуске код программы загружается сначала в оперативную память, откуда уже небольшими порциями подгружается процессору для исполнения.

Оставшаяся часть памяти используется для хранения не кода, а данных программы, в частности, переменных.  

Секция stack -- это та часть памяти, куда кладутся локальные переменные во время работы программы. Большинство переменных, которые мы заводим в программе, попадают в стек. Стек еще называется автоматической памятью.

Почему используется название “стек”? Потому что эта часть памяти работает по принципу структуры данных стек, которую вы изучали в курсе алгоритмов. Рассмотрим идею этого на простейшем примере:

```cpp
int main() {
 int a = 1;
 { 
   int b = 2;
 }
 int c = 3;
}
```
  
Изначально, когда начинает выполняться функция main, стек пуст.[^1] При создании переменной a она кладется в стек, тем самым в стеке теперь лежит один элемент и занято 4 байта. Далее туда кладется переменная b, итого в стеке два элемента и занято 8 байт. Когда заканчивается локальная область видимости b, эта переменная снимается со стека. Теперь в стеке снова всего один элемент и занято лишь 4 байта. Когда переменная снимается со стека, память в месте из-под нее не затирается, просто она теперь считается отжившей, и вершина стека смещается назад.

Когда создается переменная c, она тоже кладется в стек, и в стеке снова занято 8 байт, вершина стека снова сдвинулась вперед. Но те 4 байта, которые раньше были заняты переменной b, оказались теперь заняты переменной c! Теперь вы понимаете, как может получиться так, что память из-под одних локальных переменных оказывается переиспользована другими локальными переменными.[^2] В конце, когда завершается функция main, все переменные снимаются со стека, и происходит это в порядке, обратном тому, в котором они туда складывались.

Что происходит, когда в программе присутствуют вызовы функций, кроме main? Рассмотрим второй пример:

```cpp
void foo(int a, int b) {
  int c = 3;
  a = b + c;
} 

int main() {
  int a = 1;
  int b = 2;
  foo(a, b);
  a += b;
}
```
Когда происходит вызов функции foo, очевидно, компилятор должен создать копии переменных a и b и положить их на стек, чтобы в функции они стали локальными переменными, не связанными с исходными a, b. После чего происходит прыжок на то место исполняемого кода, где хранится код функции foo. Так что в начале выполнения foo на стеке лежит уже четыре переменных: a, b из main, после чего еще локальные a, b. Переменная c кладется на стек уже после них всех. При выходе из функции foo со стека снимается сначала c, потом b и a, и выполнение возвращается в функцию main в строчку a += b.

Однако тут возникает некоторая трудность. Откуда во время выполнения процессор знает, на какую инструкцию ему надо прыгнуть после того, как он закончил выполнять foo? Когда речь идет о вызове foo, такой вопрос не стоит: реализация функции foo лежит в секции text по заранее известному адресу, и в исполняемом коде main написано, куда прыгать на вызов foo(a, b). Но ведь foo может вызываться из разных мест, поэтому не может быть заранее известно, куда надо прыгать после окончания ее исполнения. Отсюда вывод: при входе в foo на стеке нужно сохранить, кроме копий переменных a и b, еще кое-что, а именно адрес возврата. Это указатель на ту инструкцию из секции text, на которую надо будет вернуться после окончания исполнения foo в данном случае. Таким образом, вызов foo требует уже не 8, а как минимум 16 байт памяти на стеке: для двух параметров типа int и одного указателя.[^3]

**Упражнение 2.2.1.** Провести эксперимент и изучить, сколько реально байт на стеке отнимает один вызов функции, в зависимости от количества аргументов этой функции. Исследовать, в каком порядке на стеке располагаются аргументы функции относительно друг друга и относительно адреса возврата.

А сколько всего байт доступно на стеке? Ответ таков: размер стека, как и размер секций text и data, изначально фиксирован при запуске программы. Операционная система выделяет программе под стек некоторое заранее известное количество байт. Обычно это несколько мегабайт, например, в моем случае это 8 МБ. Во время работы программы сдвигается только вершина стека, но общее количество памяти, выделенное под стек, обычно остается неизменным.[^4]

Теперь понятно, что произойдет, если в функции foo снова вызвать функцию foo без каких-либо условий, то есть создать бесконечную рекурсию. Даже если бы функция foo вообще не принимала аргументов, каждый ее вызов отъедал бы от стека как минимум 8 байт на адрес возврата, а значит, после примерно 1М вызовов стек бы закончился. Дальше бы начала использоваться память, которая нашей программе уже не принадлежит, и в какой-то момент бы случился Segmentation fault по уже понятным причинам. Такая ситуация называется **stack overflow (переполнение стека)**. Именно в честь этой ошибки и был назван самый популярный сайт с ответами на вопросы программистов.

Чтобы узнать, какой размер стека дается запускаемым программам по умолчанию, нужно в терминале выполнить команду: ulimit -s

Выведется число (в килобайтах), показывающее текущий размер стека. В моем случае вывелось 8192, что как раз означает 8 мегабайт. Можно изменить это число. Скажем, чтобы сделать его равным 16 МБ, надо выполнить команду: ulimit -s 16384

**Упражнение 2.2.2.** Экспериментальным путем выяснить, сколько нужно уровней рекурсии, чтобы произошел Segfault в вашем случае. Затем увеличить размер стека и посмотреть, как изменилось это число.

Существуют способы узнать текущий размер стека, а также изменить его из кода самой программы, для этого надо обратиться к некоторым функциям операционной системы. Но мы не будем сейчас обсуждать эти детали.  

Прежде чем завершить обсуждать стек, сделаем две оговорки. Во-первых, совершенно не стоит ожидать, что все локальные переменные реально будут складываться на стек в том порядке, в котором вы их объявили, а объявление переменной c сразу после уничтожения переменной b непременно затрет эту переменную. Компилятор имеет право упорядочивать переменные на стеке так, как ему удобно. Стандарт не обязывает компилятор выкладывать переменные на стек каким-то определенным образом. Более того, Стандарт вообще не требует от компилятора класть локальные переменные на стек (может быть, какие-то переменные было бы удобнее сразу положить в регистры процессора и даже не занимать под них оперативную память). Всё это -- отдельная сложная тема, которой мы касаемся сейчас лишь поверхностно, потому что наша цель сейчас -- понять лишь основную идею.

Ссылка для интересующихся: https://stackoverflow.com/questions/1102049/order-of-local-variable-allocation-on-the-stack

Во-вторых, по историческим причинам стек обычно заполняется не “слева направо”, а “справа налево”. То есть те переменные, которые положены на стек раньше, имеют бОльшие значения адресов. Ссылка для интересующихся: https://stackoverflow.com/questions/4560720/why-does-the-stack-address-grow-towards-decreasing-memory-addresses

Может возникнуть вопрос: почему размер стека такой маленький? А если моей программе требуется гигабайт оперативной памяти, что делать, не запрашивать же стек такого размера? Ответ заключается в том, что стек по задумке предназначен для хранения лишь локальных переменных, которые не должны быть большими. Если же вашей программе требуются большие объемы памяти, то следует использовать **динамическую память**.

Динамическая память называется так потому, что, в отличие от остальной памяти, ее выделение вашей программе происходит уже в runtime, то есть во время выполнения программы, а не заранее перед запуском. (Это уже второй раз, когда мы встретились с термином “динамический”. Первый раз был, когда мы обсуждали статическую и динамическую типизацию.)

Для выделения переменных в динамической памяти в языке C++ существует **оператор new**. Для примера рассмотрим, как выделить одну переменную типа int в динамической памяти. Это будет выглядеть так:  

```cpp
int* p = new int;
```

Здесь “new int” -- это выражение, в котором new -- это унарный оператор. Возвращаемый тип этого выражения -- int* (а если бы мы выделяли не int, а некоторый тип T, то возвращаемым типом был бы T*). Поэтому, чтобы сохранить результат этого выражения в переменной, мы используем переменную типа int*, которую я назвал p (разумеется, можно было бы назвать как угодно по-другому).

Что происходит при вычислении данного выражения? По сути, наша программа говорит операционной системе: “дорогая операционная система, дай, пожалуйста, вдобавок к имеющейся у меня памяти еще sizeof(int) байт из имеющейся у тебя оперативной памяти, и верни мне адрес начального байта из тех, что ты мне дала”. Адрес, который мы получим, будет значительно отличаться от адресов переменных, лежащих на стеке. Это будет адрес, указывающий куда-то “во внешние просторы” оперативной памяти, за пределы того, что было изначально дано нашей программе при запуске. Тем не менее, мы можем быть уверены, что 4 байта, считая от этого адреса, теперь принадлежат нашей программе, и можно спокойно разыменовывать этот указатель и присваивать новое значение выражению *p. Однако обращение хотя бы на 1 байт за пределы этих четырех байт -- это UB.

Можно сразу же при создании переменной в динамической памяти проинициализировать ее, например:

```cpp
int* p = new int(5);
```

Это приведет к тому, что под p сразу же окажется значение 5. Можно было бы написать new int() с пустыми круглыми скобками, тогда бы там оказался 0. Вместо круглых скобок также можно использовать и фигурные: new int{}. Но если не поставить никаких скобок, как мы это сделали изначально, то под p будет лежать неопределенное значение.  

После того как вы закончили пользоваться динамической памятью, которую выделили с помощью оператора new, нужно обязательно освободить ее. Для этого используется **оператор delete**. Выглядит это следующим образом:

```cpp
int* p = new int();
// usage of p
delete p;
```
  
Оператор delete -- это противоположность оператору new. Он принимает указатель и ничего не возвращает (то есть возвращает void). Действие этого оператора заключается в том, что программа сообщает операционной системе “память под этим указателем мне больше не нужна, считай ее отныне свободной”. После этого память под данным указателем перестает принадлежать вашей программе, и разыменование данного указателя с этого момента будет приводить к UB.

Оператор delete предназначен лишь для освобождения динамической памяти, и вызывать его можно лишь от тех указателей (в смысле численного значения), которые ранее были получены как результат вызова оператора new. Если вызвать delete от любого другого указателя -- это будет UB, а на практике, скорее всего, RE. В частности, вызов delete от какого-нибудь указателя, указывающего на стековую переменную -- это почти наверняка segfault. Если вы даже вызовете delete от немного сдвинутого указателя относительно того, что вернул вам new -- это UB.

Оператор delete можно вызывать только от указателей, попытка применить delete к чему-либо, не являющемуся указателем, -- это CE.

А что будет, если вызвать delete от правильного указателя, а потом еще раз сделать delete от того же указателя? Тоже UB. На практике, скорее всего, вы получите RE с примерно следующим текстом:  

```
free(): double free detected in tcache 2
Aborted (core dumped)
```
  

Эта проблема называется проблемой **двойного удаления (double free)**. Мы сейчас не будем подробно разбирать, что означают все эти слова и что такое tcache 2. Однако необходимо усвоить, что операционная система, скорее всего, убьет вашу программу, если вы попытаетесь дважды освободить одну и ту же динамическую память. Эта ошибка -- довольно частая причина падений программ в C++. Поэтому, если в коде вы используете оператор delete, нужно очень аккуратно следить, что вы его вызываете лишь от нужного указателя и лишь один раз.  

Можно спросить: а что будет, если просто не делать delete? Тогда возникнет другая проблема, называемая **утечкой памяти (memory leak)**.


TODO “delete p, pp”  

TODO сборщики мусора

TODO: статическая память, статические локальные переменные


[^1]: Не совсем. Но для первого знакомства с темой проще считать, что это так.

[^2]: И вновь нужно сделать оговорку, что в реальности в данном примере, скорее всего, так не случится, всё будет несколько сложнее. Но для первого знакомства удобнее представлять себе всё так, как я описал.

[^3]: На самом деле вызов функции отнимает от стека еще больше памяти, чем просто сумма размеров аргументов и адреса возврата. Но мы вновь не будем углубляться в детали сейчас.

[^4]: И это тоже не совсем правда, но вновь для первого знакомства мы не будем вдаваться в детали.
